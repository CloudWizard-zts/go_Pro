# 1.什么是泛型？
1.泛型即开发过程中编写适用于所有类型的模板，只有在具体使用的时候才能确定其真正的类型。

# 2.泛型的定义
```go
func getMaxNumInt(a, b int) int {
	if a > b {
		return a
	}
	return b
}

func getMaxNumFloat(a, b float64) float64 {
	if a > b {
		return a
	}
	return b
}

// 泛型
func getMaxNum[T int | float64](a, b T) T {
	
}
```
我们可以通过在函数名后面加[]来定义泛型，[T int | float64] T是int类型或者float64类型
有一种情况类型需要使用interface{}括起来：
```go
# 定义一个泛型结构体
# 默认情况下，会被格式化为T乘与int，而不是T的类似是指针
type getMax [T*int | *float64()]struct {
}

# 这种情况只需要用interface括起来即可
type getMax[T interface{ *int | *float64 }] struct {

```
# 3.泛型的示例1
```go
package main

import "fmt"

func getMaxNumInt(a, b int) int {
	if a > b {
		return a
	}
	return b
}

func getMaxNumFloat(a, b float64) float64 {
	if a > b {
		return a
	}
	return b
}

func getMaxNum[T int | float64](a, b T) T {
	if a > b {
		return a
	}
	return b
}

func main() {
	a, b := 3, 4
	c, d := 5.1, 6.1
	fmt.Println("不使用泛型：", getMaxNumInt(a, b))
	fmt.Println("不使用泛型：", getMaxNumFloat(c, d))

	// 自动推导类型
	fmt.Println("使用泛型：", getMaxNum(a, b))
	// 手动指定传入的类型
	fmt.Println("使用泛型：", getMaxNum[float64](c, d))
}
```
# 4.泛型的示例2
```go
// 如果我们的T是所有的int类型，所有的float类型，那么这个方法就要写的很长，这种情况下我们可以自定义一个类型
type CusNumT interface {
	// 定义了uint8，int32，float64
	// ~int64 的意思是 除了int64之外的所有类型全部支持
	uint8 | int32 | float64 | ~int64
}
```
